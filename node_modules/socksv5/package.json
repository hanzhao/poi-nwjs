{
  "name": "socksv5",
  "version": "0.0.4",
  "author": {
    "name": "Brian White",
    "email": "mscdex@mscdex.net"
  },
  "description": "SOCKS protocol version 5 server and client implementations for node.js",
  "main": "./index",
  "scripts": {
    "test": "node test/test.js"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "keywords": [
    "socks",
    "socks5",
    "socksv5",
    "proxy"
  ],
  "dependencies": {
    "ipv6": "^3.1.1"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/mscdex/socksv5/raw/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/mscdex/socksv5.git"
  },
  "readme": "Description\n===========\n\nSOCKS protocol version 5 server and client implementations for node.js\n\n\nRequirements\n============\n\n* [node.js](http://nodejs.org/) -- v0.10.0 or newer\n\n\nInstall\n=======\n\n    npm install socksv5\n\n\nExamples\n========\n\n* Server with no authentication and allowing all connections:\n\n```javascript\nvar socks = require('socksv5');\n\nvar srv = socks.createServer(function(info, accept, deny) {\n  accept();\n});\nsrv.listen(1080, 'localhost', function() {\n  console.log('SOCKS server listening on port 1080');\n});\n\nsrv.useAuth(socks.auth.None());\n```\n\n* Server with username/password authentication and allowing all (authenticated) connections:\n\n```javascript\nvar socks = require('socksv5');\n\nvar srv = socks.createServer(function(info, accept, deny) {\n  accept();\n});\nsrv.listen(1080, 'localhost', function() {\n  console.log('SOCKS server listening on port 1080');\n});\n\nsrv.useAuth(socks.auth.UserPassword(function(user, password, cb) {\n  cb(user === 'nodejs' && password === 'rules!');\n}));\n```\n\n* Server with no authentication and redirecting all connections to localhost:\n\n```javascript\nvar socks = require('socksv5');\n\nvar srv = socks.createServer(function(info, accept, deny) {\n  info.dstAddr = 'localhost';\n  accept();\n});\nsrv.listen(1080, 'localhost', function() {\n  console.log('SOCKS server listening on port 1080');\n});\n\nsrv.useAuth(socks.auth.None());\n```\n\n* Server with no authentication and denying all connections not made to port 80:\n\n```javascript\nvar socks = require('socksv5');\n\nvar srv = socks.createServer(function(info, accept, deny) {\n  if (info.dstPort === 80)\n    accept();\n  else\n    deny();\n});\nsrv.listen(1080, 'localhost', function() {\n  console.log('SOCKS server listening on port 1080');\n});\n\nsrv.useAuth(socks.auth.None());\n```\n\n* Server with no authentication, intercepting all connections to port 80, and passing through all others:\n\n```javascript\nvar socks = require('socksv5');\n\nvar srv = socks.createServer(function(info, accept, deny) {\n  if (info.dstPort === 80) {\n    var socket;\n    if (socket = accept(true)) {\n      var body = 'Hello ' + info.srcAddr + '!\\n\\nToday is: ' + (new Date());\n      socket.end([\n        'HTTP/1.1 200 OK',\n        'Connection: close',\n        'Content-Type: text/plain',\n        'Content-Length: ' + Buffer.byteLength(body),\n        '',\n        body\n      ].join('\\r\\n'));\n    }\n  } else\n    accept();\n});\nsrv.listen(1080, 'localhost', function() {\n  console.log('SOCKS server listening on port 1080');\n});\n\nsrv.useAuth(socks.auth.None());\n```\n\n* Client with no authentication:\n\n```javascript\nvar socks = require('socksv5');\n\nvar client = socks.connect({\n  host: 'google.com',\n  port: 80,\n  proxyHost: '127.0.0.1',\n  proxyPort: 1080\n}, function(socket) {\n  console.log('>> Connection successful');\n  socket.write('GET /node.js/rules HTTP/1.0\\r\\n\\r\\n');\n  socket.pipe(process.stdout);\n});\n\nclient.useAuth(socks.auth.None());\n```\n\n* HTTP(s) client requests using a SOCKS Agent:\n\n```javascript\nvar socks = require('socksv5');\nvar http = require('http');\n\nvar socksConfig = {\n  proxyHost: 'localhost',\n  proxyPort: 1080,\n  auths: [\n    socks.auth.None()\n  ]\n};\n\nhttp.get({\n  host: 'google.com',\n  port: 80,\n  method: 'HEAD',\n  path: '/',\n  agent: new socks.HttpAgent(socksConfig)\n}, function(res) {\n  res.resume();\n  console.log(res.statusCode, res.headers);\n});\n\n// and https too:\nvar https = require('https');\n\nhttps.get({\n  host: 'google.com',\n  port: 443,\n  method: 'HEAD',\n  path: '/',\n  agent: new socks.HttpsAgent(socksConfig)\n}, function(res) {\n  res.resume();\n  console.log(res.statusCode, res.headers);\n});\n```\n\n\nAPI\n===\n\nExports\n-------\n\n* **Server** - A class representing a SOCKS server.\n\n* **createServer**([< _function_ >connectionListener]) - _Server_ - Similar to `net.createServer()`.\n\n* **Client** - A class representing a SOCKS client.\n\n* **connect**(< _object_ >options[, < _function_ >connectListener]) - _Client_ - `options` must contain `port`, `proxyHost`, and `proxyPort`. If `host` is not provided, it defaults to 'localhost'.\n\n* **createConnection**(< _object_ >options[, < _function_ >connectListener]) - _Client_ - Aliased to `connect()`.\n\n* **auth** - An object containing built-in authentication handlers for Client and Server instances:\n\n    * **(Server usage)**\n\n        * **None**() - Returns an authentication handler that permits no authentication.\n\n        * **UserPassword**(< _function_ >validateUser) - Returns an authentication handler that permits username/password authentication. `validateUser` is passed the username, password, and a callback that you call with a boolean indicating whether the username/password is valid.\n\n    * **(Client usage)**\n\n        * **None**() - Returns an authentication handler that uses no authentication.\n\n        * **UserPassword**(< _string_ >username, < _string_ >password) - Returns an authentication handler that uses username/password authentication.\n\n* **HttpAgent** - An Agent class you can use with `http.request()`/`http.get()`. Just pass in a configuration object like you would to the Client constructor or `connect()`.\n\n* **HttpsAgent** - Same as `HttpAgent` except it is for use with `https.request()`/`https.get()`.\n\n\nServer events\n-------------\n\nThese are the same as [net.Server](http://nodejs.org/docs/latest/api/net.html#net_class_net_server) events, with the following exception(s):\n\n* **connection**(< _object_ >connInfo, < _function_ >accept, < _function_ >deny) - Emitted for each new (authenticated, if applicable) connection request. `connInfo` has the properties:\n\n    * **srcAddr** - _string_ - The remote IP address of the client that sent the request.\n\n    * **srcPort** - _integer_ - The remote port of the client that sent the request.\n\n    * **dstAddr** - _string_ - The destination address that the client has requested. This can be a hostname or an IP address.\n\n    * **dstPort** - _integer_ - The destination port that the client has requested.\n\n    `accept` has a boolean parameter which if set to `true`, will return the underlying `net.Socket` for you to read from/write to, allowing you to intercept the request instead of proxying the connection to its intended destination.\n\n\nServer methods\n--------------\n\nThese are the same as [net.Server](http://nodejs.org/docs/latest/api/net.html#net_class_net_server) methods, with the following exception(s):\n\n* **(constructor)**([< _object_ >options[, < _function_ >connectionListener]]) - Similar to `net.Server` constructor with the following extra `options` available:\n\n    * **auths** - _array_ - A pre-defined list of authentication handlers to use (instead of manually calling `useAuth()` multiple times).\n\n* **useAuth**(< _function_ >authHandler) - _Server_ - Appends the `authHandler` to a list of authentication methods to allow for clients. This list's order is preserved and the first authentication method to match that of the client's list \"wins.\" Returns the Server instance for chaining.\n\n\nClient events\n-------------\n\n* **connect**(< _Socket_ >connection) - Emitted when handshaking/negotiation is complete and you are free to read from/write to the connected socket.\n\n* **error**(< _Error_ >err) - Emitted when a parser, socket (during handshaking/negotiation), or DNS (if `localDNS` and `strictLocalDNS` are `true`) error occurs.\n\n* **close**(< _boolean_ >had_error) - Emitted when the client is closed (due to error and/or socket closed).\n\n\nClient methods\n--------------\n\n* **(constructor)**(< _object_ >config) - Returns a new Client instance using these possible `config` properties:\n\n    * **proxyHost** - _string_ - The address of the proxy to connect to (defaults to 'localhost').\n\n    * **proxyPort** - _integer_ - The port of the proxy to connect to (defaults to 1080).\n\n    * **localDNS** - _boolean_ - If `true`, the client will try to resolve the destination hostname locally. Otherwise, the client will always pass the destination hostname to the proxy server for resolving (defaults to true).\n\n    * **strictLocalDNS** - _boolean_ - If `true`, the client gives up if the destination hostname cannot be resolved locally. Otherwise, the client will continue and pass the destination hostname to the proxy server for resolving (defaults to true).\n\n    * **auths** - _array_ - A pre-defined list of authentication handlers to use (instead of manually calling `useAuth()` multiple times).\n\n* **connect**(< _mixed_ >options[, < _function_ >connectListener]) - _Client_ - Similar to `net.Socket.connect()`. Additionally, if `options` is an object, you can also set the same settings passed to the constructor.\n\n* **useAuth**(< _function_ >authHandler) - _Server_ - Appends the `authHandler` to a list of authentication methods to allow for clients. This list's order is preserved and the first authentication method to match that of the client's list \"wins.\" Returns the Server instance for chaining.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/mscdex/socksv5/issues"
  },
  "homepage": "https://github.com/mscdex/socksv5",
  "_id": "socksv5@0.0.4",
  "_from": "socksv5@>=0.0.4 <0.0.5"
}
